# name: test/sql/rewrite_data_files/test_rewrite_concurrency.test
# description: test concurrent rewrites
# group: [rewrite_data_files]

require ducklake

require parquet

require notwindows

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__


statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/ducklake_concurrent_rewrite', METADATA_CATALOG 'ducklake_metadata')

statement ok
SET ducklake_retry_wait_ms=100

statement ok
SET ducklake_retry_backoff=2.0

statement ok
use ducklake

# Start off with simple case
statement ok
CREATE TABLE test(key INTEGER, values VARCHAR);

statement ok
INSERT INTO test SELECT i, concat('thisisastring_', i) FROM range(100) t(i)

statement ok
CALL ducklake_flush_inlined_data('ducklake')

# Let's do three rounds of deletions
statement ok
DELETE FROM test
WHERE key < 39;

statement ok
DELETE FROM test
WHERE key > 90;

statement ok
DELETE FROM test
WHERE key > 41;

statement ok
CALL ducklake_flush_inlined_data('ducklake')

concurrentloop i 0 2

statement maybe
CALL ducklake_rewrite_data_files('ducklake', 'test', delete_threshold => 0);
----
attempting to compact table with index "1" - but another transaction has compacted it

endloop

query II
FROM test
----
39	thisisastring_39
40	thisisastring_40
41	thisisastring_41

# verify we have exactly 2 data files: one old (ended) and one new (active)
query I
SELECT count(*) FROM ducklake_metadata.ducklake_data_file WHERE end_snapshot IS NOT NULL
----
1

query I
SELECT count(*) FROM ducklake_metadata.ducklake_data_file WHERE end_snapshot IS NULL
----
1

# compute snapshot IDs dynamically so the test works in both inline and no-inline modes
# s_insert = the INSERT snapshot
statement ok
SET VARIABLE s_insert = (SELECT min(snapshot_id) FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%insert%=[1]%');

# s_del1, s_del2, s_del3 = the three DELETE snapshots (either tables_deleted_from or inlined_delete, but not rewrite_delete)
statement ok
SET VARIABLE s_del1 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%delete%=[1]%' AND changes::VARCHAR NOT LIKE '%rewrite%') WHERE rn = 1);

statement ok
SET VARIABLE s_del2 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%delete%=[1]%' AND changes::VARCHAR NOT LIKE '%rewrite%') WHERE rn = 2);

statement ok
SET VARIABLE s_del3 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%delete%=[1]%' AND changes::VARCHAR NOT LIKE '%rewrite%') WHERE rn = 3);

# s_rewrite = the rewrite snapshot
statement ok
SET VARIABLE s_rewrite = (SELECT min(snapshot_id) FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%rewrite_delete%=[1]%');

# s_last = last snapshot
statement ok
SET VARIABLE s_last = (SELECT max(snapshot_id) FROM ducklake_snapshots('ducklake'));

# Lets time travel
query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_insert'))
----
100

query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_del1'))
----
61

query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_del2'))
----
52

query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_del3'))
----
3

query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_rewrite'))
----
3

query I
SELECT count(*) FROM test AT (VERSION => getvariable('s_last'))
----
3

# verify files are scheduled for deletion after rewrite
query I
SELECT COUNT(*) >= 1 FROM ducklake_metadata.ducklake_files_scheduled_for_deletion
----
true

# verify delete files have been ended (end_snapshot IS NOT NULL) after rewrite
query I
SELECT COUNT(*) FROM ducklake_metadata.ducklake_delete_file WHERE end_snapshot IS NOT NULL
----
1