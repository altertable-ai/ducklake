# name: test/sql/compaction/compaction_alter_table.test
# description: test compaction on a database that is altered
# group: [compaction]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__


statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/ducklake_compaction_alter_files')

# snapshot 1 (create)
statement ok
CREATE TABLE ducklake.test(id INTEGER, i INTEGER);

# snapshot 2 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (1, 10);

# snapshot 3 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 4 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (2, 20);

# snapshot 5 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 6 (alter)
statement ok
ALTER TABLE ducklake.test ADD COLUMN j INTEGER

# snapshot 7 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (3, 30, 300);

# snapshot 8 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 9 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (4, 40, 400);

# snapshot 10 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 11 (alter)
statement ok
ALTER TABLE ducklake.test DROP COLUMN i

# snapshot 12 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (5, 500);

# snapshot 13 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 14 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (6, 600);

# snapshot 15 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 16 (alter)
statement ok
ALTER TABLE ducklake.test ADD COLUMN i VARCHAR

# snapshot 17 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (7, 700, 'hello');

# snapshot 18 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

# snapshot 19 (inlined_insert)
statement ok
INSERT INTO ducklake.test VALUES (8, 800, 'world');

# snapshot 20 (flushed_inlined)
statement ok
CALL ducklake_flush_inlined_data('ducklake')

query IIII
SELECT rowid, * FROM ducklake.test ORDER BY ALL
----
0	1	NULL	NULL
1	2	NULL	NULL
2	3	300	NULL
3	4	400	NULL
4	5	500	NULL
5	6	600	NULL
6	7	700	hello
7	8	800	world

query I
SELECT COUNT(*) FROM GLOB('${DATA_PATH}/ducklake_compaction_alter_files/**/*')
----
8

# compute dynamic snapshot IDs for time travel queries
# the 2nd insert snapshot (after 2nd insert, before any alter) - schema is (id, i)
statement ok
SET VARIABLE s2 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%insert%=[1]%') WHERE rn = 2);

# the 4th insert snapshot (after 4th insert, after ALTER ADD j) - schema is (id, i, j)
statement ok
SET VARIABLE s4 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%insert%=[1]%') WHERE rn = 4);

# the 6th insert snapshot (after 6th insert, after ALTER DROP i) - schema is (id, j)
statement ok
SET VARIABLE s6 = (SELECT snapshot_id FROM (SELECT snapshot_id, row_number() OVER (ORDER BY snapshot_id) AS rn FROM ducklake_snapshots('ducklake') WHERE changes::VARCHAR LIKE '%insert%=[1]%') WHERE rn = 6);

query III
SELECT table_name, files_processed, files_created FROM ducklake_merge_adjacent_files('ducklake') ORDER BY ALL
----
test	2	1
test	2	1
test	2	1
test	2	1

# we cannot merge across alter statements - so this results in 4 separate merges
query I
SELECT COUNT(*) FROM GLOB('${DATA_PATH}/ducklake_compaction_alter_files/**/*')
----
12

statement ok
CALL ducklake_cleanup_old_files('ducklake', cleanup_all => true);

# four files remain
query I
SELECT COUNT(*) FROM GLOB('${DATA_PATH}/ducklake_compaction_alter_files/**/*')
----
4

# verify correct behavior when operating on the compacted file
# time travel
# s2 = 2nd insert snapshot: schema is (id, i) - no j column yet
query III
SELECT rowid, * FROM ducklake.test AT (VERSION => getvariable('s2')) ORDER BY ALL
----
0	1	10
1	2	20

# s4 = 4th insert snapshot: schema after ALTER ADD j is (id, i, j)
query IIII
SELECT rowid, * FROM ducklake.test AT (VERSION => getvariable('s4')) ORDER BY ALL
----
0	1	10	NULL
1	2	20	NULL
2	3	30	300
3	4	40	400

# s6 = 6th insert snapshot: schema after ALTER DROP i is (id, j)
query III
SELECT rowid, * FROM ducklake.test AT (VERSION => getvariable('s6')) ORDER BY ALL
----
0	1	NULL
1	2	NULL
2	3	300
3	4	400
4	5	500
5	6	600

# Current state (rowids are now 0-based after compaction)
query IIII
SELECT rowid, * FROM ducklake.test ORDER BY ALL
----
0	1	NULL	NULL
1	2	NULL	NULL
2	3	300	NULL
3	4	400	NULL
4	5	500	NULL
5	6	600	NULL
6	7	700	hello
7	8	800	world
