# name: test/sql/stats/topn_file_pruning.test
# description: Ensure Top-N dynamic filters prune files using min/max column stats
# group: [stats]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__

statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/ducklake_topn_pruning')

statement ok
PRAGMA threads=1;

statement ok
CREATE TABLE ducklake.events(timestamp TIMESTAMP, user_id VARCHAR);

# Create multiple data files with increasing timestamp ranges
statement ok
INSERT INTO ducklake.events
SELECT TIMESTAMP '2026-01-01 00:00:00' + interval (i) second, 'a' FROM range(1000) t(i);

statement ok
INSERT INTO ducklake.events
SELECT TIMESTAMP '2026-01-02 00:00:00' + interval (i) second, 'b' FROM range(500) t(i);

statement ok
INSERT INTO ducklake.events
SELECT TIMESTAMP '2026-01-03 00:00:00' + interval (i) second, 'c' FROM range(200) t(i);

statement ok
INSERT INTO ducklake.events
SELECT TIMESTAMP '2026-01-04 00:00:00' + interval (i) second, 'd' FROM range(100) t(i);

# The Top-N phase should not need to read all files once the dynamic filter is initialized
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.events ORDER BY timestamp DESC LIMIT 1
----
analyzed_plan	<REGEX>:.*optional: Dynamic Filter.*100 rows.*

# Verify correct result for timestamp DESC LIMIT 1
query II
SELECT * FROM ducklake.events ORDER BY timestamp DESC LIMIT 2
----
2026-01-04 00:01:39	d
2026-01-04 00:01:38	d

# Test ascending order Top-N
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.events ORDER BY timestamp ASC LIMIT 1
----
analyzed_plan	<REGEX>:.*optional: Dynamic Filter.*1,000 rows.*

# Verify correct result for timestamp ASC LIMIT 2
query II
SELECT * FROM ducklake.events ORDER BY timestamp ASC LIMIT 2
----
2026-01-01 00:00:00	a
2026-01-01 00:00:01	a

# Test combined Top-N with WHERE clause - both should contribute to pruning
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.events WHERE timestamp > TIMESTAMP '2026-01-02 00:00:00' ORDER BY timestamp DESC LIMIT 5
----
analyzed_plan	<REGEX>:.*optional: Dynamic Filter.*

# Test with multiple sort orders - should still prune using first column
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.events ORDER BY timestamp DESC, user_id ASC LIMIT 1
----
analyzed_plan	<REGEX>:.*optional: Dynamic Filter.*100 rows.*

# Verify actual result is correct with multiple sort orders
query IT
SELECT * FROM ducklake.events ORDER BY timestamp DESC, user_id ASC LIMIT 1
----
2026-01-04 00:01:39	d

# NULLS FIRST disables the optimization so this should read all files (see FIXME in duckdb/src/optimizer/topn_optimizer.cpp)
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.events ORDER BY timestamp DESC NULLS FIRST LIMIT 1
----
analyzed_plan	<REGEX>:.*1,800 rows.*

# Test Top-N pruning with partitioned table - should only read files from matching partitions
statement ok
CREATE TABLE ducklake.partitioned_events(part_key INTEGER, timestamp TIMESTAMP);

statement ok
ALTER TABLE ducklake.partitioned_events SET PARTITIONED BY (part_key);

# Insert 1 row per partition with different timestamps
statement ok
INSERT INTO ducklake.partitioned_events VALUES (1, TIMESTAMP '2026-01-01 00:00:00');

statement ok
INSERT INTO ducklake.partitioned_events VALUES (2, TIMESTAMP '2026-01-02 00:00:00');

# Top-N query filtering to a specific partition - should only read files from that partition
# The main TABLE_SCAN (reading part_key, timestamp, user_id) should only read 1 file from the matching partition
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.partitioned_events WHERE part_key = 2 ORDER BY timestamp DESC LIMIT 1
----
analyzed_plan	<REGEX>:.*TABLE_SCAN.*Total Files Read: 1.*TABLE_SCAN.*Total Files Read: 1.*

# Top-N query on the partition key should only scan 1 file from the matching partition out of the 2
query II
EXPLAIN ANALYZE SELECT * FROM ducklake.partitioned_events ORDER BY part_key DESC LIMIT 1
----
analyzed_plan	<REGEX>:.*TABLE_SCAN.*Total Files Read: 2.*Total Files Scanned:.*1.*TABLE_SCAN.*Total Files Read: 2.*Total Files Scanned:.*1.*

